# Quick DDD Notes

## Model

The, so called, **Model** is the abstraction of the **Domain**.

The Domain comes to light talking to the _Domain Experts_, which are the
business experts.

The abstraction is the model. This is not a diagram but the idea that the
diagram is intended to convey.

Sometime the domain contain too much, so we must leave parts out of our model.

We should be able to communicate the Model.

- Graphical Diagrams
- Writing
- Language

Only once we are sure we can communicate the model we can start to design our
code.

**Software Design:** The big pictures, where the walls of a house are going to
be placed.

**Code Design:** Detail, where certain painting is going to be hang.

Code design mistakes are easy to correct, the totally opposite happens with
Software design mistakes.

**Analysis Paralysis:** Teams members so afraid of making any design decision
that end up making no progress at all.

## The Ubiquitous Language

One different person uses different words when writing than when speaking.
Sometimes, even in the same sentences.

A core principle of DDD is to use a language **based on the model**.

That language and the models are strongly interconnected with one another. A
change in the language is a change in the model.

**_Domain experts should easily understands the both the language and the
model._**

The language can be expressed in text, diagrams, etc. (UML diagrams are not
recommended by this book)

## Model Driven Design

**Very important details are discovered during the design and implementation
process.** A Model that is truthful to the Domain can turn out to have serious
problems with object persistence, or unacceptable performance behaviour. The
Model should be constructed with an eye open to the software and design
considerations. **Developers should be included in the modeling process**. This
ensures that the model can actually be implemented.

"Procedural programming does not suit well Model driven Design"

### The building blocks of a Model Driven Design

![Model Driven Design](img/2021-06-22-11-25-26.png)

```
**Lo que me cuesta entender de este Diagrama:**

* **Entieties** *act as root* and *mantains integrity* with **Aggregates**

* **Model Driven Design** *express model* with **Value Objects**
```

## Layered Architecture

A common architectural solution for domain-driven designs contain four conceptual layers:

**User Interface** (Presentation Layer):
Responsible for presenting information to the user and interpreting user
commands.

**Application Layer:**
This is a thin layer which coordinates the application activity. It does not
contain business logic. It does not hold the state of the business objects, but
it can hold the state of an application task progress.

**Domain Layer:**
This layer contains information about the domain. This is the heart of the business
software. The state of business objects is held here. Persistence of the
business objects and possibly their state is delegated to the infrastructure layer.

**Infrastructure Layer:** This layer acts as a supporting library for all the
other layers. It provides communication between layers, implements persistence
for business objects, contains supporting libraries for the user interface
layer, etc.

## Entities

Entities are necessary objects in the domain model and should be considered
from beginning of the modeling.

An Object must be an Entity as long as it has identity. For these objects is not
the attributes that matter, but the thread of continuity and identity.

Usually the identity is either an attribute of the object, a combination of
attributes or an attribute specially created to preserve and express identity,
or even a behaviour.
The "ID" could be auto generated by a module, could be the PK of a table in a DB
or it could be created by the user.

This means of identification may come from outside or it may be created by and
for the system, bit it must correspond to the identity distinctions in the model.
The model must define what it means to be the same thing.

Beware of considering all objects entities, there may be performance issues.
(Consider the case of a drawing App explained in the book)

## Value Objects

There are cases where we need to contain some attributes of a domain element we
are not interested in which object it is, but what attributes it has. An object
that is used to describe certain aspects of a domain, and which does not have
identity, is name value object.

It is highly recommendable that these objects are immutable, even more if they
are sharable

Value objects  should stay thin, making a copy of a V.O should be easy.

Value Objects, can contain other value objects, and they can even contain
references to entities. Although V.O attributes of a domain object, that does
not mean that it should contain a long list with all the attributes.
Attributes can be grouped in different objects. Attributes chosen to make up a
V.O should form a conceptual whole.
 
![Value Objects](img/2021-06-22-15-47-12.png)

## Services
